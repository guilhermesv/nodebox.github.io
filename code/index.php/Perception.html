<html>

<head>
<title>NodeBox | Perception</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="imagetoolbar" content="no" />
<meta http-equiv="linode" content="true"/>
<meta name="description" content="" />
<meta name="keywords" content="NodeBox, Perception, semantic network, perception, creativity" />
<link rel="alternate" type="application/rss+xml" title="NodeBox News Feed" href="https://nodebox.net/code/data/rss.xml" />
<link rel="canonical" href="https://nodebox.net/code/index.php/Perception" />
<link type="text/css" rel="stylesheet" media="screen" href="../../media/css/nbar.css">

<script type="text/javascript" src="../js/pop.js"></script>
<script type="text/javascript" src="../js/confirm.js"></script>
<link href="../css/default.css" rel="stylesheet" type="text/css" />
<link href="../css/print.css" rel="stylesheet" type="text/css" media="print" />
<!--[if gte IE 5.5]>
<script type="text/javascript" src="/code/js/pngfix.js"></script>
<![endif]-->

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-1668598-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>

<body id="body" >
<div class="nbar">
  <ol>
    <li><a class="node" href="https://www.nodebox.net/code/">NodeBox 1<span class="nbar-arrow"></span></a>
      <ol class="nbar-dropdown">
        <li><a href="https://www.nodebox.net/">Homepage</a></li>
        <li><a href="https://www.nodebox.net/node/">NodeBox 3<small>Node-based app for generative design and data visualization</small></a></li>
        <li><a href="https://www.nodebox.net/opengl/">NodeBox OpenGL<small>Hardware-accelerated cross-platform graphics library</small></a></li>
        <li><a href="https://www.nodebox.net/code/">NodeBox 1<small>Generate 2D visuals using Python code (Mac OS X only)</small></a></li>
      </ol>
    </li>
    <li><a class="gallery" href="https://www.nodebox.net/gallery/">Gallery</a></li>
    <li><a class="documentation" href="Tutorial.html">Documentation</a></li>
    <li><a class="forum" href="http://support.nodebox.net/discussions">Forum</a></li>
    <li><a class="blog" href="https://www.nodebox.net/blog/">Blog</a></li>
  </ol>
</div>


<div id="all">
<div id="header_and_navigation">

<div id="header">
<a href="Home.html"><img id="header_image" src="../g/header-small.jpg" width="800" /></a></div>

<div id="title">
<a href="Home.html"><h1>NodeBox</h1>
<strong><em>Create visual output with Python programming code</em></strong>
</a></div>

<div id="contextual">
<div id="languages">
 
</div>

<div id="search">
<form id = "sf" method="get">
<input type="text" id="q" name="q" value="" />
<a href="javascript:document.getElementById('sf').submit();">GO</a>
</form>
</div>

</div>

<div id="navigation">
<div id="navigation_public">
<a id="" href="Home.html">Home</a> 
<a id="" href="Download.html">Download</a> 
<a id="" href="Reference.html">Reference</a> 
<a id="" href="Tutorial.html">Tutorial</a> 
<a id="" href="Library.html">Library</a> 
<a id="" href="Gallery.html">Gallery</a> 
<a id="" href="Share.html">Share</a> 
<a id="" href="About.html">About</a> 
</div>
</div>
 
</div>

<div id="content">

<div id="nodebox-link">
<a href="Home.html"><img src="../g/transparent.gif" /></a>
</div>

<div class="inside">
<? if (do_name() != 'Home') : ?>
 <h3>Perception</h3><? endif ?>
<h2>Description</h2><p>  The purpose of the NodeBox Perception module is to incorporate commonsense knowledge into NodeBox of how things look, feel, smell and relate to other things. The data is organized in a so-called <a href="http://en.wikipedia.org/wiki/Semantic_network" target="_self">semantic network</a> (like WordNet). Concepts in a semantic network are connected to each other with  semantic relations. For example: <i>red is-property-of rose.</i></p><p>The module has two parts: <a href="http://nodebox.net/perception" target="_blank">an online application</a> where you can add new rules to the network, and a NodeBox library to retrieve clusters of rules and analyze them. The library uses the functionality in the <a href="Graph.html" target="_self">Graph</a> library to find shortest paths and strong concepts in the network. It also contains a <i>simile</i> search technique as discussed by Dr. Tony Veale and Yanfen Hao in their paper [<a href="http://afflatus.ucd.ie/Papers/LearningFigurative_CogSci07.pdf" target="_self">1</a>].<br /></p><p class="pink_text">The library introduces some advanced programming concepts. </p><h2>Download</h2>  <table border="0"><tbody><tr><td><img src="../data/media/download.gif" alt="download" /></td><td><p><b>Application</b>: <a href="http://nodebox.net/perception" target="_blank">http://nodebox.net/perception</a> <br /><b>Library</b>: <a href="https://www.nodebox.net/code/data/media/perception.zip" target="_self">perception.zip</a> (250KB)<br /><b>Dependencies:</b> <a href="Graph.html" target="_self">Graph</a> library (latest version)<i><br />Beta version<br /></i><i>Licensed under GPL</i><br /><i>Authors: Tom De Smedt, Frederik De Bleser<br /></i></p></td></tr></tbody></table><h2>Documentation  </h2><ul><li><a href="Perception.html#relations" target="_self">Semantic relations</a></li><li><a href="Perception.html#extend" target="_self">Extending the network</a></li><li><a href="Perception.html#library" target="_self">How to get the library up and running</a></li><li><a href="Perception.html#query" target="_self">Perception queries inside NodeBox <br /></a></li><li><a href="Perception.html#cluster" target="_self">Perception clusters inside NodeBox</a></li><li><a href="Perception.html#range" target="_self">Working with concept ranges</a></li><li><a href="Perception.html#index" target="_self">Working with the cached index</a></li><li><a href="Perception.html#solver" target="_self">Working with the solver</a></li><li><a href="Perception.html#heuristic" target="_self">Pathfinding heuristics</a><br /></li><li><a href="Perception.html#api" target="_self">REST API</a></li><li><a href="Perception.html#widget" target="_self">Widget</a><br /></li></ul><p> </p><p><a href="http://nodebox.net/perception" target="_blank" class="noexternal"><img src="http://nodebox.net/code/data/media/perception1.jpg" alt="perception1" /></a><br />    Screenshot from <a href="http://nodebox.net/perception" class="noexternal" target="_blank">http://nodebox.net/perception</a>.<br />The application is built to work with the Safari and Firefox browsers. </p><p> </p><hr size="2" width="100%" /><h2><a title="relations" name="relations"></a>Semantic relations</h2><p>Concepts in the Perception network are connected to each other with semantic relations. The advantage of using these semantic rules is that they make sense to both people and machines. </p><p>There are lots of existing and well-known semantic networks (WordNet and Wikipedia to name two). Our purpose is not to recreate these - instead, in the Perception network we <b>focus on the <i>is-property-of</i> relation</b> which describes what something looks or feels like. This will yield the sort of sensory, emotional, subjective knowledge we want in a visualization tool like NodeBox.<br /></p><p>The network supports six different relations:</p><ul><li><b>is-a</b>: shorthand for <i>is-a-type-of</i>. This relation is called a hyponym-hypernym relation. It connects a specific concept to a larger class of similar concepts, e.g.<i> Helvetica</i><i> is-a sans-serif.</i></li><li><b>is-part-of</b>: this relation is called a meronym-holonym relation. It defines the parts of a whole, components, members, substances, e.g. <i>typography is-part-of layout</i>.</li><li><b>is-opposite-of</b>: this relation is called an antonymy. It defines opposites, e.g. <i>legibility is-opposite-of illegiblity</i>.</li><li><b>is-property-of</b>: shorthand for <i>is-sensory-property-of. </i>The concept on the left tells something about how the word of the right looks, feels, sounds, smells, or is processed emotionally. For example: <i>dark is-property-of night</i>, <i>sharp is-property-of knife. </i>We call this a perceptonymy.  </li><li><b>is-related-to</b>: an associative relation. Two concepts linked in this way are psychologically related, e.g. <i>David Carson is-related-to grunge</i>. </li><li><b>is-same-as</b>: this relation is called a synonymy, both related concepts are equals, e.g. <i>font is-same-as typeface</i>.<br /><br /></li></ul><p><span class="grey_box">Properties</span> <br /></p><p>Everything that has an <i>is-property-of</i> relation to another concept is regarded as a sensory property. Properties are at the heart of the network because we can use them to <b>translate language to visual output </b>(which is the main goal of the Perception module).</p><p>At one end we have people using conceptual constraints like <i>bright and trendy colors</i>, at the other end we have machines with technological possibilities like a <i>HSB color model</i>. We can easily define <i>bright</i> in terms of saturation and brightness, and <i>trendy</i> in terms of specific hues (like pink). The <a href="Colors.html" target="_blank">Colors</a> library offers a few tools to do that. Hence, <i>bright</i> and <i>trendy</i> are useful sensory go-betweens. When we start tagging other concepts with these properties (e.g <i>bright is-property-of sun</i>) we are basically teaching machines something about aesthetics and the visual world.</p><p>If you open up the "from property" window in the web app you'll notice that some properties are highlighted. These are properties we think are good candidates to connect to pieces of NodeBox code to generate associated visual output.<br /><br /> </p><p><span class="grey_box">Context</span> </p><p>Sets of related rules are organized in a context, like <i>nature</i> or <i>culture</i>. Contexts can be used as a filter to narrow down the rules being displayed.<br /></p><p> </p><hr size="2" width="100%" /><h2><a title="extend" name="extend"></a>Extending the network </h2><p><span class="grey_box">Authorship</span>  </p><p>When you <a href="http://nodebox.net/perception" target="_blank">add your own rules</a> to the network you are encouraged to <b>leave an e-mail address</b> or some other identification code. This way, your own set of rules can be set apart from all the other rules - you can filter for your ID so you only get to see your own data, regardless of what anyone else is saying. </p><p>We encourage you to use your e-mail address. If the tool catches on and lots of people are going to be adding rules, we may want to contact you to learn something about your cultural background.<br /><br /></p><p><span class="grey_box">Editing</span> <br /></p><p>At this point you can only <i>add</i> rules in the online application. If you are planning on getting your hands dirty you may need to be able to edit existing rules to reorganize or restructure clusters in the network. If this is the case, contact us and we'll set you up with some editing rights. <br /><br /></p><p><span class="grey_box">Where to start?</span> </p><p>If you don't know where to start, here are some good clusters of knowledge in the network: <br /></p><table><tbody><tr><td><b>Nature</b></td><td><b>Culture</b></td><td><b>Emotion</b></td><td><b>Media</b></td><td><b>Graphics<br /></b></td></tr><tr><td><a href="http://nodebox.net/perception?animal" target="_blank">animal<br /></a><a href="http://nodebox.net/perception?plant" target="_blank">plant</a><br /><a href="http://nodebox.net/perception?tree" target="_blank">tree</a><br /><a href="http://nodebox.net/perception?landscape" target="_blank">landscape</a><br /><a href="http://nodebox.net/perception?sky" target="_blank">sky</a><br /><a href="http://nodebox.net/perception?weather" target="_blank">weather</a><br /><a href="http://nodebox.net/perception?body" target="_blank">body</a><br /></td><td><a href="http://nodebox.net/perception?state" target="_blank">state</a><br /><a href="http://nodebox.net/perception?science" target="_blank">science</a><br /><a href="http://nodebox.net/perception?religion" target="_blank">religion</a><br /><a href="http://nodebox.net/perception?leisure" target="_blank">leisure</a><br /><a href="http://nodebox.net/perception?structure" target="_blank">structure</a></td><td><a href="http://nodebox.net/perception?facial_expression" target="_blank">facial expression</a><br /><a href="http://nodebox.net/perception?behavior" target="_blank">behavior</a><br /></td><td><a href="http://nodebox.net/perception?book" target="_blank">book</a><br /><a href="http://nodebox.net/perception?movie" target="_blank">movie</a><br /><a href="http://nodebox.net/perception?genre" target="_blank">genre</a></td><td><a href="http://nodebox.net/perception?color" target="_blank">color</a><br /><a href="http://nodebox.net/perception?text" target="_blank">text</a></td></tr></tbody></table><p> </p><p><span class="grey_box">How to start?</span> <br /></p><p>Think of a central concept that interests you. Start adding rules to it (and remember to add some <i>is-property-of</i> rules). Then start thinking about the new concepts that were introduced in your rules. You'll quickly have a good cluster of knowledge. </p><p>For example:</p><ul><li>Yoda <i>is-a</i> muppet<br /></li><li>Yoda <i>is-part-of</i> Star Wars</li><li>The Force <i>is-part-of</i> Yoda</li><li>green <i>is-property-of</i> Yoda</li><li>small <i>is-property-of</i> Yoda</li><li>powerful <i>is-property-of</i> The Force</li><li>Star Wars <i>is-a</i> movie </li></ul><br /><br /><span class="grey_box">Robots</span> <br /><p>The Perception module has a number of robots that help us out with finding new rules. One of the robots is developed at the department of Computer Linguistics at the University of Antwerp (Belgium) and has gathered over two hundred thousand <i>is-property-of</i> rules from various text sources. </p><table><tbody><tr><td><img src="http://nodebox.net/code/data/media/perception3.jpg" alt="perception3" /></td><td><p>When you click the <b>suggest</b> link in the <i>Add rule</i> panel you can review them and activate those you think make sense.</p><p>You can browse the rules starting from a property (e.g. voracious <i>is-property-of</i> predator) or by searching for concepts (e.g. predator <i>has-property </i>voracious). You can switch modes by clicking "property" or "concept" at the top of the widget.</p><p>Then simply select the rules that make senses and they'll be activated in the Perception network. <br /></p></td></tr></tbody></table><p> </p><hr size="2" width="100%" /><h2><a title="library" name="library"></a>How to get the library up and running</h2><p>Put the <i>perception</i> library folder in the same folder as your script so NodeBox can find the library. You can also put it in <i>~/Library/Application Support/NodeBox/. </i>You'll also need the <a href="Graph.html" target="_self">Graph</a> library installed. Put it in <i>Application Support </i>as well, or inside the <i>perception</i> library folder.</p>  <pre class="python">perception = <span style="color: #530035;">ximport</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;perception&quot;</span><span style="">&#41;</span></pre></pre><p class="small_text">Outside of NodeBox you can also just do <i>import perception.</i></p><p> </p><hr size="2" width="100%" /><h2><a title="query" name="query"></a>Perception queries inside NodeBox</h2><p>The simplest way to retrieve rules from the online Perception database is with the <i>query()</i> command. A list of rules will be returned - all of them involving the given <i>concept</i>, with the given <i>relation</i>, in the given <i>context</i> and/or from the given <i>author</i>.</p><pre class="python">query<span style="">&#40;</span>concept, relation=<span style="color: #530035;">None</span>, context=<span style="color: #530035;">None</span>, author=<span style="color: #530035;">None</span>, depth=<span style="">1</span><span style="">&#41;</span></pre></pre><p>If the optional <i>depth</i> is 1 the command simply returns all the rules that match. If <i>depth</i> is between 1 and 4, it returns a cluster of interconnected concepts. </p><p>This is useful because if there is a <i>wet is-property-of fog</i> rule and a <i>fog is-related-to autumn</i> rule, the command will also retrieve the <i>wet is-property-of autumn</i> rule even though we were only querying for <i>fog</i> rules. This results in much more meaningful data to put in a small "fog-graph".</p><p>Note that you can also set the author once in the AUTHOR variable. It will then be used in all queries throughout the library.</p><pre class="python">perception.<span style="">AUTHOR</span> = <span style="color: #ff0080;">&quot;alice@wonderland.com&quot;</span></pre></pre><p>Each <i>Rule</i> object in the returned list has the following properties:</p><ul><li><i>rule.concept1</i>: the "from" concept in the rule, for example <i>wet</i>.<br /> </li><li><i>rule.relation</i>: the semantic relation defining the rule, for example <i>is-property-of</i>.</li><li><i>rule.concept2</i>: the "to" concept in the rule, for example <i>fog</i>. </li><li><i>rule.context</i>: the rule's context, for example <i>nature</i>.<br /></li><li><i>rule.author</i>: the author's ID.<br /></li><li><i>rule.date</i>: rule creation date.<br /><br /></li></ul><p><span class="grey_box">Local cache</span> <br /></p><p>When you execute a query, the library attempts to connect to the online Perception database. The result is then cached locally so the next time you run the same query it will respond quicker. At some point you may want to empty the local cache:</p><pre class="python">cache_clear<span style="">&#40;</span><span style="">&#41;</span></pre></pre></p>                             <hr size="2" width="100%" /><h2><a title="cluster" name="cluster"></a>Perception clusters inside NodeBox</h2><p>Obviously, the next fun thing to do is to cluster related concepts in a small graph (like in the web application). The library builds on the <a href="Graph.html" target="_self">Graph</a> library to accomplish this. The <i>cluster()</i> command returns a graph object that has all of the functionality described in the documentation of the Graph library - that's the best place to start if you are new to graph networks. </p><pre class="python">cluster<span style="">&#40;</span>concept, relation=<span style="color: #530035;">None</span>, context=<span style="color: #530035;">None</span>, author=<span style="color: #530035;">None</span>, depth=<span style="">2</span><span style="">&#41;</span></pre></pre><p>So, it's easy enough to visualize a cluster of rules:</p><table><tbody><tr><td><p><img src="http://nodebox.net/code/data/media/perception-cluster.jpg" alt="perception-cluster" /> </p></td><td><pre class="python">g = perception.<span style="">cluster</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;fog&quot;</span><span style="">&#41;</span>
g.<span style="">distance</span> = <span style="">1.2</span>
g.<span style="">styles</span>.<span style="">apply</span><span style="">&#40;</span><span style="">&#41;</span>
g.<span style="">solve</span><span style="">&#40;</span><span style="">&#41;</span>
g.<span style="">draw</span><span style="">&#40;</span><span style="">&#41;</span></pre></pre></td></tr></tbody></table><br /><p><span class="grey_box">Concept node methods and properties</span>  </p><p>Nodes (e.g. individual concepts) in the cluster graph have all the standard node properties and methods, and some additional functionality that pertains to the Perception network:</p><pre class="python">node.<span style="">is_a</span><span style="">&#40;</span>node, direct=<span style="color: #530035;">True</span><span style="">&#41;</span></pre></pre><pre class="python">node.<span style="">is_part_of</span><span style="">&#40;</span>node. <span style="">direct</span>=<span style="color: #530035;">True</span><span style="">&#41;</span></pre></pre><pre class="python">node.<span style="">is_opposite_of</span><span style="">&#40;</span>node, direct=<span style="color: #530035;">True</span><span style="">&#41;</span></pre></pre><pre class="python">node.<span style="">is_property_of</span><span style="">&#40;</span>node, direct=<span style="color: #530035;">True</span><span style="">&#41;</span></pre></pre><pre class="python">node.<span style="">is_related_to</span><span style="">&#40;</span>node, direct=<span style="color: #530035;">True</span><span style="">&#41;</span></pre></pre><pre class="python">node.<span style="">is_same_as</span><span style="">&#40;</span>node, direct=<span style="color: #530035;">True</span><span style="">&#41;</span></pre></pre><pre class="python">node.<span style="">has_specific</span><span style="">&#40;</span>node, direct=<span style="color: #530035;">True</span><span style="">&#41;</span></pre></pre><pre class="python">node.<span style="">has_part</span><span style="">&#40;</span>node, direct=<span style="color: #530035;">True</span><span style="">&#41;</span></pre></pre><pre class="python">node.<span style="">has_property</span><span style="">&#40;</span>node, direct=<span style="color: #530035;">True</span><span style="">&#41;</span></pre></pre><p>Each of these methods returns <i>True</i> or <i>False</i>, depending on whether the two nodes are directly with the given relation. If <i>direct</i> is <i>False</i>, intermediary nodes are allowed as long as the relation stays the same. For example: </p><pre class="python">g = perception.<span style="">cluster</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;albatross&quot;</span>, depth=<span style="">3</span><span style="">&#41;</span>
<span style="color: #530035;">print</span> g.<span style="">albatross</span>.<span style="">is_a</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;animal&quot;</span>, direct=<span style="color: #530035;">False</span><span style="">&#41;</span>
&gt;&gt;&gt; <span style="color: #530035;">True</span></pre></pre><p>In this case, <i>True</i> is returned because an albatross is a bird and a bird is an animal. So albatross is an animal. Note that if the cluster query would have been executed with a <i>depth</i> of 2, the <i>animal</i> concept would have been out of reach and <i>False</i> would have been returned. Deeper clusters yield more intelligence, yet slower and more cluttered visualizations.</p><p>The following methods return a list of connected nodes by relation type: </p><pre class="python">node.<span style="">hyponyms</span><span style="">&#40;</span>depth=<span style="">1</span><span style="">&#41;</span>     <span style="color: grey;"># specific: tree =&gt; evergeen, deciduous</span></pre></pre><pre class="python">node.<span style="">hypernyms</span><span style="">&#40;</span>depth=<span style="">1</span><span style="">&#41;</span>    <span style="color: grey;"># abstract: tree =&gt; organism</span></pre></pre><pre class="python">node.<span style="">meronyms</span><span style="">&#40;</span>depth=<span style="">1</span><span style="">&#41;</span>     <span style="color: grey;"># parts: tree =&gt; bark, leaf, branch</span></pre></pre><pre class="python">node.<span style="">holonyms</span><span style="">&#40;</span>depth=<span style="">1</span><span style="">&#41;</span>     <span style="color: grey;"># group: tree =&gt; forest</span></pre></pre><pre class="python">node.<span style="">antonyms</span><span style="">&#40;</span>depth=<span style="">1</span><span style="">&#41;</span>     <span style="color: grey;"># opposites: warm &lt;=&gt; cool</span></pre></pre><pre class="python">node.<span style="">properties</span><span style="">&#40;</span>depth=<span style="">1</span><span style="">&#41;</span>   <span style="color: grey;"># tree =&gt; big, strong, old</span></pre></pre><pre class="python">node.<span style="">associations</span><span style="">&#40;</span>depth=<span style="">1</span><span style="">&#41;</span> <span style="color: grey;"># tree =&gt; squirrel, primate</span></pre></pre><pre class="python">node.<span style="">objects</span><span style="">&#40;</span>depth=<span style="">1</span><span style="">&#41;</span>      <span style="color: grey;"># illustrate property: strong =&gt; horse, tree, ...</span></pre></pre><p>With a <i>depth</i> of 1, only directly connected nodes are returned. With a <i>depth</i> of 2 nodes connected to directly connected nodes are also returned, and so on. </p><p>Nodes in a cluster graph have one extra property:</p><ul><li><i>node.is_property</i>: <i>True</i> if it is a word like <i>dark</i>, <i>big</i>, or <i>pleasant</i>.<br /><br /></li></ul><p><span class="grey_box">Concept cluster methods and properties</span>  </p><p>A concept cluster graph has all the methods and properties any other graph object has, and some additional semantic functionality:</p><pre class="python">graph.<span style="">hyponyms</span><span style="">&#40;</span>proper=<span style="color: #530035;">False</span>, fringe=<span style="">1</span><span style="">&#41;</span> <span style="color: grey;"># specify: tree =&gt; oak, linden</span></pre></pre><pre class="python">graph.<span style="">properties</span><span style="">&#40;</span>distance=<span style="">2</span><span style="">&#41;</span> <span style="color: grey;"># describe: sun =&gt; yellow, red, hot, bright</span></pre></pre><pre class="python">graph.<span style="">objects</span><span style="">&#40;</span>distance=<span style="">2</span><span style="">&#41;</span>    <span style="color: grey;"># illustrate: wild =&gt; anger, sea, rodeo</span></pre></pre><p>The <i>graph.hyponyms()</i> method analyzes the cluster and returns a list of node objects that are concrete examples of the graph's root. If proper is <i>True</i>, only proper names are returned (e.g. "God" but not "god"). The <i>fringe</i> determines how close to the perimeter of the graph the nodes are located. With a higher <i>fringe</i> value (or simply <i>None</i>) nodes can be located deeper in the cluster, nearer to the root.  </p><pre class="python">g = perception.<span style="">cluster</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;river&quot;</span>, depth=<span style="">3</span><span style="">&#41;</span>
<span style="color: #530035;">print</span> g.<span style="">hyponyms</span><span style="">&#40;</span><span style="">&#41;</span>
&gt;&gt;&gt; <span style="">&#91;</span>rivulet, brook<span style="">&#93;</span></pre></pre><p>The <i>graph.properties()</i> method analyzes the cluster and returns a list of property nodes relevant to the graph root. The <i>graph.objects()</i> method does the reverse: it returns concrete, tangible nodes if the graph's root is a property. The <i>distance</i> determines how far away from the root these nodes can be. </p><p>At this point you may wonder about the difference between using the <i>properties()</i> method on a single node or using it on a cluster graph. The difference is that the latter is <b>more elaborate</b>: it derives (or <b>infers</b>) additional knowledge from strong nodes surrounding the root. In other words: it finds more relevant nodes. And, nodes in the returned list are <b>sorted by weight</b>. For example:</p><pre class="python">g = perception.<span style="">cluster</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;sun&quot;</span>, depth=<span style="">3</span><span style="">&#41;</span>
<span style="color: #530035;">print</span> g.<span style="">sun</span>.<span style="">properties</span><span style="">&#40;</span><span style="">&#41;</span>
&gt;&gt;&gt; <span style="">&#91;</span>yellow, red, hot, <span style="">round</span>, bright<span style="">&#93;</span>
<span style="color: #530035;">print</span> g.<span style="">properties</span><span style="">&#40;</span><span style="">&#41;</span>
&gt;&gt;&gt; <span style="">&#91;</span>yellow, red, hot, bright, <span style="">round</span>, cyan, white, healthy, slow, blue, 
     orange, intense, passionate, exotic, mysterious, dangerous, organic, 
     dry, fast, chaotic, blond, important, warm<span style="">&#93;</span></pre></pre><p>The returned list contains node objects. A simple way to get to a list of strings: </p><pre class="python">g = perception.<span style="">cluster</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;sun&quot;</span>, depth=<span style="">3</span><span style="">&#41;</span>
<span style="color: #530035;">print</span> <span style="">&#91;</span>node.<span style="">id</span> <span style="color: #530035;">for</span> node <span style="color: #530035;">in</span> g.<span style="">sun</span>.<span style="">properties</span><span style="">&#40;</span><span style="">&#41;</span><span style="">&#93;</span>
&gt;&gt;&gt; <span style="">&#91;</span><span style="color: #ff0080;">&quot;yellow&quot;</span>, <span style="color: #ff0080;">&quot;red&quot;</span>, <span style="color: #ff0080;">&quot;hot&quot;</span>, <span style="color: #ff0080;">&quot;round&quot;</span>, <span style="color: #ff0080;">&quot;bright&quot;</span><span style="">&#93;</span></pre></pre>      <p>A cluster graph object has two additional properties:</p><ul><li><i>graph.proper_nouns</i>: a list of nodes in the graph that are proper nouns (e.g. "NodeBox").<br /></li><li><i>graph.proper_leaves</i>: a list of nodes in the graph that are both leaves and proper nouns. </li></ul><p> </p><hr size="2" width="100%" /><h2><a title="range" name="range"></a>Working with concept ranges </h2><p>Ranges are very different from clusters. While a cluster focuses on the details of one concept, a range is an enumeration of similar concepts. For example: <i>all the trees in Perception</i>, or <i>all the movies in Perception</i>. Such ranges are derived from <b>taxonomies</b>, graphs that show only the <i>is-a</i> relation and in which all nodes come from the same ancestor.</p><pre class="python">taxonomy<span style="">&#40;</span>concept, context, author=<span style="color: #530035;">None</span>, depth=<span style="">4</span><span style="">&#41;</span></pre></pre><pre class="python"><span style="">range</span><span style="">&#40;</span><span style="">type</span><span style="">&#41;</span></pre></pre><p>The <i>range()</i> command returns a list of concepts that are of the given <i>type</i>. The <i>type</i> is expected to be a singular word, so you query for a <i>movie range</i> instead of a <i>movies range</i>. For example:</p><pre class="python"><span style="color: #530035;">print</span> perception.<span style="">range</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;movie&quot;</span><span style="">&#41;</span> 
&gt;&gt;&gt; <span style="">&#91;</span><span style="color: #ff0080;">'Conan The Barbarian'</span>, <span style="color: #ff0080;">'Dawn of the Dead'</span>, <span style="color: #ff0080;">'Star Wars'</span>, <span style="color: #ff0080;">'The Matrix'</span><span style="">&#93;</span></pre></pre><p>One special range is the <i>properties range</i>. It contains all the concepts from Perception that fall within the properties context:</p><pre class="python"><span style="color: #530035;">print</span> perception.<span style="">range</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;properties&quot;</span><span style="">&#41;</span><span style="">&#91;</span>:<span style="">5</span><span style="">&#93;</span>
&gt;&gt;&gt; <span style="">&#91;</span><span style="color: #ff0080;">'abstract'</span>, <span style="color: #ff0080;">'agile'</span>, <span style="color: #ff0080;">'angry'</span>, <span style="color: #ff0080;">'angular'</span>, <span style="color: #ff0080;">'annoying'</span><span style="">&#93;</span></pre></pre><p>Often, the rules that define what goes into the same range need to be tweaked a little bit to get the best results. You can do this with the <i>range.append()</i> command:</p><pre class="python"><span style="">range</span>.<span style="">append</span><span style="">&#40;</span>name, concept, context, fringe=<span style="">2</span>, proper=<span style="color: #530035;">False</span><span style="">&#41;</span></pre></pre><p>Now what does this do? It tells the <i>range()</i> command that there exists a range with the given <i>name</i>. This range is made up of concepts that are connected to the ancestor <i>concept</i> with <i>is-a</i> relations, in the given <i>context</i>. All of these concepts are located in the given <i>fringe</i> of the taxonomy. If <i>proper</i> is <i>True</i>, they furthermore need to be proper nouns.</p><p>Wow, what was all of that! Let's try to clarify things with an example:</p><pre class="python">perception.<span style="">range</span>.<span style="">append</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;font&quot;</span>, <span style="color: #ff0080;">&quot;typeface&quot;</span>, <span style="color: #ff0080;">&quot;graphics&quot;</span>, fringe=<span style="">2</span>, proper=<span style="color: #530035;">True</span><span style="">&#41;</span>
<span style="color: #530035;">print</span> perception.<span style="">range</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;font&quot;</span><span style="">&#41;</span>
&gt;&gt;&gt; <span style="">&#91;</span><span style="color: #ff0080;">'Arial'</span>, <span style="color: #ff0080;">'Beowolf'</span>, <span style="color: #ff0080;">'Comic Sans MS'</span>, <span style="color: #ff0080;">'Courier'</span>, ... <span style="">&#93;</span></pre></pre><p>What the above rule means is that a font is a concept with a proper name that has typeface as an ancestor. We only look in the graphics context - this avoids ambuigity - and define a rather narrow fringe to avoid that font category names (e.g. "Serif") also end up in the range.</p><p>All of the tweaked range rules are stored in the <i>range.rules </i>dictionary. So you can find out what ranges have already been defined by printing out <i>range.rules.keys()</i>. </p><p> </p><hr size="2" width="100%" /><h2><a title="index" name="index"></a>Working with the cached index </h2><p>So far we have looked at how to retrieve a lists of rules from the Perception database, construct and analyze a cluster of related rules and retrieve a range of concept siblings. Let's take it a step further and look at how we can find paths between different, unrelated clusters.</p><pre class="python">index.<span style="">shortest_path</span><span style="">&#40;</span>concept1, concept2<span style="">&#41;</span></pre></pre><pre class="python">index.<span style="">nearest</span><span style="">&#40;</span>root, concepts<span style="">&#41;</span></pre></pre><pre class="python">index.<span style="">sort_by_distance</span><span style="">&#40;</span>root, concepts<span style="">&#41;</span></pre></pre><p>The <i>index.shortest_path()</i> command returns a list of concepts describing how to get from <i>concept1</i> to <i>concept2</i> in the quickest way. The <i>index.nearest()</i> command returns the concept from the list of <i>concepts</i> that is nearest to the <i>root</i> concept. The <i>index.sort_by_distance() </i>command returns the list of <i>concepts</i> sorted by distance from the <i>root</i> concept.</p><p>For example, which is darker: being happy or being sad? </p><pre class="python"><span style="color: #530035;">print</span> perception.<span style="">index</span>.<span style="">nearest</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;dark&quot;</span>, <span style="">&#91;</span><span style="color: #ff0080;">&quot;happy&quot;</span>, <span style="color: #ff0080;">&quot;sad&quot;</span><span style="">&#93;</span><span style="">&#41;</span> 
&gt;&gt;&gt; sad</pre></pre><p>Note that since <i>index</i> itself is a dictionary you can also do <i>index.has_key()</i>, <i>index.keys()</i>, etc.</p><p>Now how does this index work on the inside? Obviously, finding a good path between two random concepts takes quite a bit of time and effort. For this reason, the index is cached locally on your machine instead of requesting shortest paths from the online application. Check out the <i>index/</i> folder inside the library. You'll notice a "properties" file. This is the cached set we are currently using: it contains all the shortest paths between all of the properties in Perception.</p><p>You can also create your own custom sets:</p><pre class="python">index.<span style="">build</span><span style="">&#40;</span>name, concepts=<span style="">&#91;</span><span style="">&#93;</span>, heuristic=<span style="color: #530035;">None</span><span style="">&#41;</span></pre></pre><p>This will create a new file with the given name, containing the shortest paths between all the concepts in the given list. Below is an example script of how to build a new properties set. Be aware that even for 100-200 concepts it might very well take an hour to build the new set. You'll also need an active internet connection.<br /></p><pre class="python">perception.<span style="">index</span>.<span style="">build</span><span style="">&#40;</span>
    <span style="color: #ff0080;">&quot;properties&quot;</span>,
    perception.<span style="">range</span>.<span style="">properties</span>,
    perception.<span style="">cost</span><span style="">&#40;</span><span style="color: #530035;">None</span>, <span style="">&#123;</span><span style="color: #ff0080;">&quot;is-property-of&quot;</span>:<span style="">-0.25</span>,<span style="color: #ff0080;">&quot;is-opposite-of&quot;</span>:<span style="">10</span><span style="">&#125;</span><span style="">&#41;</span>
<span style="">&#41;</span></pre></pre><p>You may wonder about the heuristic parameter - we'll get to that in the <a href="Perception.html#heuristics" target="_self">heuristics</a> chapter below. <br /></p><p>To switch between different cached sets, simply change the index name:</p><pre class="python">perception.<span style="">index</span>.<span style="">name</span> = <span style="color: #ff0080;">&quot;properties&quot;</span></pre></pre></p>                   <hr size="2" width="100%" /><h2><a title="solver" name="solver"></a>Working with the solver</h2><p>The solver combines clusters, ranges and the index to make decisions about the real world. The <i>solver.find()</i> command will filter and sort the list of given concepts according to how relevant they are to the <i>given</i> root concept.<br /></p><pre class="python">solver.<span style="">find</span><span style="">&#40;</span>root, concepts<span style="">&#41;</span></pre></pre><p>For example, we could use it to find a typeface that matches a certain feel:</p><pre class="python">concepts = perception.<span style="">range</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;font&quot;</span><span style="">&#41;</span>
<span style="color: #530035;">print</span> perception.<span style="">solver</span>.<span style="">find</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;funny&quot;</span>, concepts<span style="">&#41;</span>
&gt;&gt;&gt; <span style="">&#91;</span><span style="color: #ff0080;">'Sauna'</span>, <span style="color: #ff0080;">'Helvetica'</span>, <span style="color: #ff0080;">'Arial'</span>, <span style="color: #ff0080;">'Dolly'</span><span style="">&#93;</span> <span style="color: grey;"># funny fonts?</span></pre></pre><pre class="python">concepts = perception.<span style="">range</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;font&quot;</span><span style="">&#41;</span>
<span style="color: #530035;">print</span> perception.<span style="">solver</span>.<span style="">find</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;structured&quot;</span>, concepts<span style="">&#41;</span>
&gt;&gt;&gt; <span style="">&#91;</span><span style="color: #ff0080;">'Verdana'</span>, <span style="color: #ff0080;">'Georgia'</span>, <span style="color: #ff0080;">'Dolly'</span>, <span style="color: #ff0080;">'Arial'</span><span style="">&#93;</span> <span style="color: grey;"># structured fonts?</span></pre></pre><pre class="python">concepts = perception.<span style="">range</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;color&quot;</span><span style="">&#41;</span>
<span style="color: #530035;">print</span> perception.<span style="">solver</span>.<span style="">find</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;creepy&quot;</span>, concepts<span style="">&#41;</span>
&gt;&gt;&gt; <span style="">&#91;</span><span style="color: #ff0080;">'black'</span>, <span style="color: #ff0080;">'blue'</span>, <span style="color: #ff0080;">'azure'</span><span style="">&#93;</span> <span style="color: grey;"># creepy colors?</span></pre></pre><pre class="python">concepts = perception.<span style="">range</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;emotion&quot;</span><span style="">&#41;</span>
<span style="color: #530035;">print</span> perception.<span style="">solver</span>.<span style="">find</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;dark&quot;</span>, concepts<span style="">&#41;</span>
&gt;&gt;&gt; <span style="">&#91;</span><span style="color: #ff0080;">'disgust'</span>, <span style="color: #ff0080;">'sadness'</span>, <span style="color: #ff0080;">'pride'</span>, <span style="color: #ff0080;">'fear'</span>, <span style="color: #ff0080;">'anger'</span><span style="">&#93;</span> <span style="color: grey;"># dark emotions?</span></pre></pre><p>Note that there is no randomness involved except when the solver needs to make a choice between two exactly equal concepts. The process is entirely dependent on the rules people have added to the Perception database (so obviously, at times you will disagree with the solver's suggestions).  In short, this is what happens behind the scenes:</p><ul><li>For each concept in the list, create a cluster.</li><li>Analyze the cluster for strong properties that best describe this concept.</li><li>Find the shortest path between the best of these properties and the given <i>root</i> property. <br /></li><li>If it's shorter than the best candidate so far, add it to the list of candidates.</li></ul><p>If you want to use the solver with something else besides properties, you will need to create your own index. Also, the cluster graph needs a method that returns the concepts you want. In a hypothetical example, you could redefine the workings of the solver as follows:<br /></p><pre class="python"><span style="color: #530035;">def</span> <span style='color:rgb(255,0,50)'>my_analysis</span><span style="">&#40;</span>graph<span style="">&#41;</span>:
    <span style="color: grey;"># Our own custom analysis!</span>
    <span style="color: grey;"># It is expected to yield a list of the nodes </span>
    <span style="color: grey;"># we find interesting in the graph.</span>
    <span style="color: #530035;">return</span> graph.<span style="">nodes_by_betweenness</span><span style="">&#40;</span><span style="">&#41;</span><span style="">&#91;</span><span style="">0</span>:<span style="">1</span><span style="">&#93;</span>
&nbsp;
perception.<span style="">graph</span>.<span style="">add_method</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;my_analysis&quot;</span>, my_analysis<span style="">&#41;</span>
perception.<span style="">solver</span>.<span style="">index</span> = <span style="color: #ff0080;">&quot;properties&quot;</span>
perception.<span style="">solver</span>.<span style="">method</span> = <span style="color: #ff0080;">&quot;my_analysis&quot;</span></pre></pre>  <p>That said, let's have a look at pathfinding heuristics used in the library.</p><p> </p><hr size="2" width="100%" /><h2><a title="heuristic" name="heuristic"></a>Pathfinding heuristics</h2><p>When building a cached index, we may want to discourage certain type of relations. For example, a  shortest path that has an <i>is-opposite-of</i> in it somewhere is probably not a path that makes much sense. Consider that a tree is "organic", and that "artificial" is the opposite of organic, and that a computer is artificial. This makes the distance between trees and computers very short, but that's not really a good thing when we want to compare trees to other organic things (which - obviously - computers are not).</p><p>We can pass an optional <i>heuristic</i> parameter to the <i>index.build()</i> command. This heuristic (i.e. loosely defined search rule) is a command that takes two node id's and returns a cost, usually a number between -1.0 and 1.0. Links that cost less are preferred over more expensive ones, even if this means a longer path between two nodes. The Perception library offers a handy <i>heuristic()</i> builder to construct search rules:</p><pre class="python">heuristic<span style="">&#40;</span>costs=<span style="">&#123;</span><span style="">&#125;</span>, graph=<span style="color: #530035;">None</span><span style="">&#41;</span></pre></pre><p>The <i>heuristic()</i> command returns something you can pass to <i>index.build()</i>. The <i>costs</i> parameter is a dictionary of relations linking to costs. This way you can tax individual relations. For example, to build a decent index that ignores <i>is-opposite-of</i> relations and encourages <i>is-property-of</i> relations:</p><pre class="python">h = perception.<span style="">heuristic</span><span style="">&#40;</span><span style="">&#123;</span><span style="color: #ff0080;">&quot;is-property-of&quot;</span>: <span style="">-0.25</span>, <span style="color: #ff0080;">&quot;is-opposite-of&quot;</span>: <span style="">10</span><span style="">&#125;</span><span style="">&#41;</span>
perception.<span style="">index</span>.<span style="">build</span><span style="">&#40;</span>
    <span style="color: #ff0080;">&quot;properties&quot;</span>,
    perception.<span style="">range</span><span style="">&#40;</span><span style="color: #ff0080;">&quot;properties&quot;</span><span style="">&#41;</span>,
    heuristic=h
<span style="">&#41;</span></pre></pre><p>Note that the <i>graph.properties()</i> and <i>graph.objects()</i> methods also have an optional heuristic parameter to tweak the returned results. </p><p>With the combination of the online input module, clusters, ranges, customizable indexes and the solver you can start doing anything you want. If you feel like getting your hands dirty, pop open the library's source code and see what else is possible. </p><p> </p>    <hr size="2" width="100%" /><h2><a title="api" name="api"></a>REST API</h2><p>If you require data from the Perception network outside of NodeBox, that's possible with the simple query API. You can direct your software to the Perception URL, add some query arguments and retrieve clusters of rules in plain text, JSON or XML format.</p><pre class="python">http://nodebox.<span style="">net</span>/perception?<span style="">&#91;</span>concept<span style="">&#93;</span></pre></pre><p>Arguments:</p><ul><li><span class="inline_code">format</span>: either <span class="inline_code">txt</span>, <span class="inline_code">json</span> or <span class="inline_code">xml</span>.<br /><span class="inline_code"></span></li><li><span class="inline_code">relation</span>: only return rules involving the given relation.</li><li><span class="inline_code">context</span>: only return rules in the given context.</li><li><span class="inline_code">author</span>: only return rules from the given author.</li><li><span class="inline_code">user</span>: the e-mail address you use as your author identification. When data is returned you won't be able to see the ID's other authors use, but you can supply your own one as user to ensure it isn't obfuscated.</li><li><span class="inline_code">depth</span>: without this argument you simply get a list of all the rules in the network that match the above criteria. With a depth argument (between 2 and 4), you get a <i>cluster</i> of relevant concepts surrounding your given query concept. Clusters are useful to analyze as graphs. </li></ul><p>For example, to get some properties regarding flowers:</p><pre class="python">http://nodebox.<span style="">net</span>/perception/?flower&amp;format=txt&amp;relation=is-property-of</pre></pre><p>This will yield something like the result below:</p><pre class="python"><span style="color: #ff0080;">'feminine'</span>, <span style="color: #ff0080;">'is-property-of'</span>, <span style="color: #ff0080;">'flower'</span>, <span style="color: #ff0080;">'nature'</span>, <span style="color: #ff0080;">'author1'</span>, <span style="color: #ff0080;">'2008-04-17'</span>
<span style="color: #ff0080;">'naive'</span>, <span style="color: #ff0080;">'is-property-of'</span>, <span style="color: #ff0080;">'flower'</span>, <span style="color: #ff0080;">'nature'</span>, <span style="color: #ff0080;">'author1'</span>, <span style="color: #ff0080;">'2008-04-17'</span>
<span style="color: #ff0080;">'elegant'</span>, <span style="color: #ff0080;">'is-property-of'</span>, <span style="color: #ff0080;">'flower'</span>, <span style="color: #ff0080;">'nature'</span>, <span style="color: #ff0080;">'author1'</span>, <span style="color: #ff0080;">'2008-04-17'</span></pre></pre></p>        <br /><hr size="2" width="100%" /><h2><a title="widget" name="widget"></a>Widget</h2><p><a href="https://www.nodebox.net/code/data/media/NodeBoxPerception.wdgt.zip" target="_self">Download</a> the Dashboard widget to keep track of updates to the Perception module:<br /></p><p><iframe src="../../perception/widget.php.html" scrolling="no">&amp;lt;br /&amp;gt;&amp;lt;/p&amp;gt;</iframe></p><? include("util/comment.php"); ?>
</div>
  
</div>

<div id="footer">
Last modified: Nov 27 2012 | &copy; 2004-2012 <a href="http://www.emrg.be/" class="noexternal">Experimental Media Research Group</a>
</div>
<img src="../g/footer.jpg" style="border:0" class="footer" width="800" height="334" />

</div>

<script>
try{e=document.getElementsByTagName("span");for(i=0;i<e.length;i++){if(e[i].className=="header_image"){src=e[i].getElementsByTagName("img")[0].src;document.getElementById("header_image").src=src;break;}}}catch(e){}
</script>
</body>

</html>